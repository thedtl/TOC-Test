<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Universal PDF Booker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <style>
    :root { --primary: #2563eb; --bg: #f8fafc; --border: #e5e7eb; --text: #1e293b; --success: #16a34a; --err: #dc2626; }
    body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); color: var(--text); padding: 20px; max-width: 850px; margin: 0 auto; }
    .card { background: white; border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
    h1, h2 { margin-top: 0; }
    .hidden { display: none !important; }
    
    /* Inputs */
    input[type="text"], input[type="number"] { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; box-sizing: border-box; }
    .row { display: flex; gap: 15px; margin-bottom: 10px; }
    .col { flex: 1; }
    label { font-weight: 600; font-size: 0.9rem; display: block; margin-bottom: 5px; }

    /* Buttons */
    button { cursor: pointer; padding: 10px 16px; border-radius: 6px; border: none; font-weight: 600; transition: opacity 0.2s; }
    button:hover { opacity: 0.9; }
    .btn-primary { background: var(--primary); color: white; width: 100%; }
    .btn-sec { background: #e2e8f0; color: #475569; }
    .btn-success { background: var(--success); color: white; width: 100%; font-size: 1.1rem; padding: 15px; }
    .btn-del { background: #fee2e2; color: var(--err); padding: 4px 8px; }

    /* Status */
    .status { margin-top: 15px; padding: 12px; border-radius: 8px; font-size: 0.95rem; }
    .status.processing { background: #eff6ff; color: #1e40af; border: 1px solid #dbeafe; }
    .status.success { background: #f0fdf4; color: #166534; border: 1px solid #bbf7d0; }
    .status.error { background: #fef2f2; color: #991b1b; border: 1px solid #fecaca; }

    /* Chapters */
    .chap-row { display: flex; gap: 10px; align-items: center; padding: 8px; border-bottom: 1px solid #f1f5f9; }
    .chap-row:first-child { border-top: 1px solid #f1f5f9; }
    .chap-title { flex: 3; }
    .chap-page { flex: 1; text-align: center; }
    
    /* PDF Preview */
    canvas { width: 100%; border: 1px solid var(--border); border-radius: 8px; margin-top: 15px; }
  </style>
</head>
<body>

  <h1>üìö Universal PDF Booker</h1>

  <!-- Step 1: Upload -->
  <div class="card" id="step-upload">
    <h2>1. Select PDF</h2>
    <div style="margin-bottom: 15px;">
        <label>URL (Dropbox/Direct)</label>
        <div style="display: flex; gap: 10px;">
            <input type="text" id="pdf-url" placeholder="https://...">
            <button class="btn-primary" style="width: auto;" onclick="loadFromUrl()">Load</button>
        </div>
    </div>
    <div style="text-align: center; margin: 10px; color: #94a3b8;">‚Äî OR ‚Äî</div>
    <input type="file" id="pdf-file" accept=".pdf">
    <div id="upload-status" class="status hidden"></div>
  </div>

  <!-- Step 2: Settings & Scan -->
  <div class="card hidden" id="step-scan">
    <h2>2. Analyze</h2>
    <p style="color: #64748b; font-size: 0.9rem; margin-bottom: 15px;">
        This will scan the first 15 pages and last 5 pages to find the ToC.
    </p>
    <button class="btn-primary" onclick="runScan()">‚ú® Scan with AI</button>
    <div id="scan-status" class="status hidden"></div>
  </div>

  <!-- Step 3: Editor -->
  <div class="card hidden" id="step-edit">
    <h2>3. Verify & Download</h2>
    
    <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
        <div class="row">
            <div class="col">
                <label>PDF Page where "1" starts:</label>
                <div style="display:flex; gap:5px;">
                    <input type="number" id="offset-arabic" value="1">
                    <button class="btn-sec" style="width:auto;" onclick="setOffset('arabic')">Set Current</button>
                </div>
            </div>
            <div class="col">
                <label>First Printed Page #</label>
                <input type="number" id="first-num" value="1">
            </div>
        </div>
        <div class="row">
            <div class="col">
                <label>Preview Page:</label>
                <div style="display:flex; gap:5px; align-items:center;">
                    <button class="btn-sec" style="width:auto;" onclick="changePage(-1)">‚Üê</button>
                    <input type="number" id="prev-page" value="1" onchange="renderPage()">
                    <button class="btn-sec" style="width:auto;" onclick="changePage(1)">‚Üí</button>
                </div>
            </div>
        </div>
    </div>

    <canvas id="the-canvas"></canvas>

    <h3>Chapters Found</h3>
    <div id="chapter-container"></div>
    <button class="btn-sec" onclick="addChapterRow()" style="margin-top:10px;">+ Add Chapter</button>

    <div style="margin-top: 30px; text-align: center;">
        <input type="text" id="filename" placeholder="output.pdf" style="margin-bottom: 10px; text-align: center;">
        <button class="btn-success" onclick="downloadPdf()">‚¨áÔ∏è Download Bookmarked PDF</button>
        <div id="dl-status" class="status hidden"></div>
    </div>
  </div>

<script>
// --- CONFIG ---
const BACKEND = "https://toc-backend-482285058910.us-west3.run.app"; // Your URL
const PROXY = "https://toc-pdf-proxy.ccrawford.workers.dev/?url=";
pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

// --- STATE ---
let pdfDoc = null;
let pdfBytes = null; // Uint8Array
let totalPages = 0;
let currPage = 1;

// --- UPLOAD ---
document.getElementById('pdf-file').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if(!file) return;
    setStatus('upload-status', 'processing', 'Reading file...');
    try {
        const buffer = await file.arrayBuffer();
        await loadPdfData(new Uint8Array(buffer), file.name);
    } catch(err) {
        setStatus('upload-status', 'error', err.message);
    }
});

async function loadFromUrl() {
    const url = document.getElementById('pdf-url').value;
    if(!url) return;
    setStatus('upload-status', 'processing', 'Downloading...');
    try {
        const res = await fetch(PROXY + encodeURIComponent(url));
        if(!res.ok) throw new Error("Download failed");
        const buff = await res.arrayBuffer();
        await loadPdfData(new Uint8Array(buff), "document.pdf");
    } catch(err) {
        setStatus('upload-status', 'error', err.message);
    }
}

async function loadPdfData(data, fname) {
    pdfBytes = data;
    pdfDoc = await pdfjsLib.getDocument(data).promise;
    totalPages = pdfDoc.numPages;
    document.getElementById('filename').value = fname.replace(".pdf", "_bookmarked.pdf");
    
    setStatus('upload-status', 'success', `Loaded ${totalPages} pages.`);
    document.getElementById('step-scan').classList.remove('hidden');
    document.getElementById('step-preview').classList.remove('hidden'); // Legacy ID compatibility
    
    // Show preview immediately
    renderPage(1);
}

// --- SCANNING ---
async function runScan() {
    setStatus('scan-status', 'processing', 'Scanning Front & Back matter (this takes ~15s)...');
    
    const formData = new FormData();
    const blob = new Blob([pdfBytes], {type: 'application/pdf'});
    formData.append("pdf_file", blob, "doc.pdf");

    try {
        const res = await fetch(`${BACKEND}/analyze-pdf-ai`, { method: "POST", body: formData });
        const data = await res.json();
        
        if(data.error) throw new Error(data.error);
        
        // Populate Data
        document.getElementById('offset-arabic').value = data.arabic_start_pdf_page || 1;
        document.getElementById('first-num').value = data.first_page_number || 1;
        
        const container = document.getElementById('chapter-container');
        container.innerHTML = '';
        
        if(!data.entries || data.entries.length === 0) {
            setStatus('scan-status', 'error', 'AI found no chapters. You can add them manually.');
        } else {
            data.entries.forEach(ch => addChapterRow(ch.title, ch.page));
            setStatus('scan-status', 'success', `Found ${data.entries.length} chapters.`);
        }
        
        document.getElementById('step-edit').classList.remove('hidden');
        document.getElementById('step-scan').classList.add('hidden'); // Hide scan button to declutter

    } catch(err) {
        setStatus('scan-status', 'error', err.message);
        // Show edit anyway so manual entry is possible
        document.getElementById('step-edit').classList.remove('hidden');
    }
}

// --- UI HELPERS ---
function addChapterRow(title="", page="") {
    const div = document.createElement('div');
    div.className = 'chap-row';
    div.innerHTML = `
        <input type="text" class="chap-title" value="${title.replace(/"/g, '&quot;')}" placeholder="Title (Author)">
        <input type="text" class="chap-page" value="${page}" placeholder="Pg">
        <button class="btn-del" onclick="this.parentElement.remove()">√ó</button>
        <button class="btn-sec" onclick="previewChap(this)">üëÅÔ∏è</button>
    `;
    document.getElementById('chapter-container').appendChild(div);
}

function setStatus(id, type, msg) {
    const el = document.getElementById(id);
    el.className = `status ${type}`;
    el.textContent = msg;
    el.classList.remove('hidden');
}

// --- PREVIEW ---
function changePage(delta) {
    currPage = Math.max(1, Math.min(totalPages, parseInt(document.getElementById('prev-page').value) + delta));
    document.getElementById('prev-page').value = currPage;
    renderPage();
}

function setOffset(type) {
    document.getElementById(`offset-${type}`).value = currPage;
}

function previewChap(btn) {
    const row = btn.parentElement;
    const pStr = row.querySelector('.chap-page').value;
    const pNum = parseInt(pStr);
    
    if(!isNaN(pNum)) {
        const offset = parseInt(document.getElementById('offset-arabic').value);
        const firstPrint = parseInt(document.getElementById('first-num').value);
        
        // Logic: Target PDF Page = (Printed Page - First Printed Page) + Offset
        // e.g. Printed 6, First Printed 1, Offset 10 -> (6-1)+10 = 15
        const target = (pNum - firstPrint) + offset;
        if(target > 0 && target <= totalPages) {
            currPage = target;
            document.getElementById('prev-page').value = currPage;
            renderPage();
        }
    }
}

async function renderPage() {
    const num = parseInt(document.getElementById('prev-page').value);
    const page = await pdfDoc.getPage(num);
    const viewport = page.getViewport({scale: 1.5});
    const canvas = document.getElementById('the-canvas');
    const ctx = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;
    await page.render({canvasContext: ctx, viewport: viewport}).promise;
}

// --- WRITE PDF ---
async function downloadPdf() {
    const status = document.getElementById('dl-status');
    status.className = 'status processing';
    status.textContent = 'Writing PDF...';
    status.classList.remove('hidden');

    try {
        const { PDFDocument } = PDFLib;
        const pdf = await PDFDocument.load(pdfBytes);
        
        // Clean old bookmarks
        pdf.catalog.delete(PDFLib.PDFName.of('Outlines'));
        pdf.catalog.delete(PDFLib.PDFName.of('PageMode'));

        const outlines = [];
        const rows = document.querySelectorAll('.chap-row');
        
        const offset = parseInt(document.getElementById('offset-arabic').value) || 1;
        const firstPrint = parseInt(document.getElementById('first-num').value) || 1;

        rows.forEach(row => {
            const title = row.querySelector('.chap-title').value.trim();
            const pStr = row.querySelector('.chap-page').value.trim();
            if(!title || !pStr) return;

            let pdfIdx = 0;
            // Roman numeral handling could be added here if needed, 
            // but for now we assume Arabic input.
            const pNum = parseInt(pStr);
            if(!isNaN(pNum)) {
                pdfIdx = (pNum - firstPrint) + offset - 1; // 0-based index
            }

            if(pdfIdx >= 0 && pdfIdx < pdf.getPageCount()) {
                outlines.push({ title, pageIdx: pdfIdx });
            }
        });

        // Create Bookmarks (PDF-Lib Logic)
        const context = pdf.context;
        const outlineRef = context.nextRef();
        const items = [];

        for (const item of outlines) {
            const ref = context.nextRef();
            items.push({ ref, ...item });
        }

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const prev = i > 0 ? items[i - 1].ref : null;
            const next = i < items.length - 1 ? items[i + 1].ref : null;
            
            const map = new Map();
            map.set(PDFLib.PDFName.of('Title'), PDFLib.PDFHexString.fromText(item.title));
            map.set(PDFLib.PDFName.of('Parent'), outlineRef);
            map.set(PDFLib.PDFName.of('Dest'), context.obj([pdf.getPage(item.pageIdx).ref, 'XYZ', null, null, null]));
            if (prev) map.set(PDFLib.PDFName.of('Prev'), prev);
            if (next) map.set(PDFLib.PDFName.of('Next'), next);
            
            context.assign(item.ref, context.obj(map));
        }

        if(items.length > 0) {
            const rootMap = new Map();
            rootMap.set(PDFLib.PDFName.of('Type'), PDFLib.PDFName.of('Outlines'));
            rootMap.set(PDFLib.PDFName.of('First'), items[0].ref);
            rootMap.set(PDFLib.PDFName.of('Last'), items[items.length - 1].ref);
            rootMap.set(PDFLib.PDFName.of('Count'), items.length);
            
            context.assign(outlineRef, context.obj(rootMap));
            pdf.catalog.set(PDFLib.PDFName.of('Outlines'), outlineRef);
            pdf.catalog.set(PDFLib.PDFName.of('PageMode'), PDFLib.PDFName.of('UseOutlines'));
        }

        const pdfBytesOut = await pdf.save();
        const blob = new Blob([pdfBytesOut], { type: 'application/pdf' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = document.getElementById('filename').value;
        link.click();
        
        status.className = 'status success';
        status.textContent = 'Done!';
    } catch(e) {
        status.className = 'status error';
        status.textContent = e.message;
    }
}
</script>
</body>
</html>
