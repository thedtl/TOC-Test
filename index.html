<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF ToC Tool (AI Backend)</title>

  <!-- Libraries -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <style>
    :root {
      --primary: #2563eb;
      --primary-hover: #1d4ed8;
      --success: #059669;
      --danger: #dc2626;
      --warning: #d97706;
      --bg: #f8fafc;
      --border: #e5e7eb;
      --text: #111827;
      --muted: #6b7280;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 22px;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }

    h1 { margin: 0 0 14px; }

    .card {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 18px;
      margin-bottom: 18px;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
    }

    .hidden { display: none !important; }

    .step-number {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      background: #e0e7ff;
      color: #3730a3;
      font-weight: 700;
      margin-right: 8px;
      font-size: 14px;
    }

    label { display: block; font-weight: 600; margin-bottom: 6px; }
    input, select, textarea {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 14px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }

    textarea { min-height: 110px; resize: vertical; }

    button {
      border: 0;
      border-radius: 9px;
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
      transition: .12s ease;
    }

    button.primary { background: var(--primary); color: #fff; }
    button.primary:hover { background: var(--primary-hover); }
    button.success { background: var(--success); color: #fff; }
    button.secondary { background: #f3f4f6; color: #111827; }
    button.secondary:hover { filter: brightness(.97); }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .status-box {
      border-radius: 10px;
      padding: 12px;
      border: 1px solid var(--border);
      background: #f9fafb;
      color: #111827;
      font-size: 14px;
      margin-top: 10px;
      overflow-wrap: anywhere;
    }
    .status-box.processing { background: #fef3c7; color: #92400e; border: 1px solid #fde68a; }
    .status-box.success { background: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
    .status-box.warning { background: #ffedd5; color: #9a3412; border: 1px solid #fed7aa; }
    .status-box.error { background: #fee2e2; color: #991b1b; border: 1px solid #fecaca; }

    .toolbar {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 8px 0;
      color: var(--muted);
      font-size: 13px;
    }

    .preview-wrap {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: flex-start;
      margin-top: 12px;
    }

    canvas {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      max-width: 100%;
      height: auto;
    }

    .chapter-row {
      display: grid;
      grid-template-columns: 26px 1fr 120px 34px;
      gap: 10px;
      align-items: center;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      margin-bottom: 10px;
      background: #fff;
    }

    .chapter-row.invalid { border-color: #fecaca; background: #fef2f2; }
    .chapter-row.warning { border-color: #fed7aa; background: #fff7ed; }

    .drag-handle {
      user-select: none;
      cursor: grab;
      color: #9ca3af;
      font-size: 18px;
      text-align: center;
    }

    .chapter-title, .chapter-page { margin-bottom: 0 !important; }

    .del-btn {
      background: #fee2e2;
      color: #991b1b;
      font-weight: 900;
      border-radius: 8px;
      padding: 8px;
    }

    .validation-msg {
      grid-column: 1 / -1;
      font-size: 12px;
      color: #991b1b;
      margin-top: 2px;
      margin-left: 36px;
    }

    .small-note {
      font-size: 12px;
      color: var(--muted);
      margin-top: -6px;
      margin-bottom: 10px;
    }

    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; }
  </style>
</head>

<body>
  <h1>üìö PDF ToC Tool (AI Backend)</h1>

  <!-- Step 1 -->
  <div class="card">
    <h2><span class="step-number">1</span> Select PDF</h2>

    <div class="status-box" style="margin-top: 10px;">
      <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:end;">
        <div style="flex:1; min-width:280px;">
          <label>Backend URL</label>
          <input type="text" id="backend-url" value="https://toc-ocr-482285058910.us-west3.run.app" />
        </div>

        <div style="width:160px;">
          <label>AI scan pages</label>
          <input type="number" id="ai-max-pages" value="40" min="1" max="200" />
        </div>

        <div style="display:flex; gap:10px; align-items:center;">
          <button id="backend-test-btn" class="secondary">Test Backend</button>
          <span id="backend-status" style="color:#666; font-size:13px;"></span>
        </div>
      </div>
      <div class="small-note">
        The AI backend endpoint used is <code>/analyze-pdf-ai</code>.
      </div>
    </div>

    <div style="display:flex; gap:15px; flex-wrap:wrap; align-items:flex-start; margin-top: 12px;">
      <div style="flex:1; min-width:200px;">
        <label style="font-size: 0.9em;">From your computer</label>
        <input type="file" id="pdf-file" accept=".pdf" />
      </div>

      <div style="display:flex; align-items:center; color:#9ca3af; font-weight:700;">OR</div>

      <div style="flex:2; min-width:280px;">
        <label style="font-size: 0.9em;">From Dropbox URL</label>
        <div style="display:flex; gap:8px;">
          <input type="text" id="pdf-url" placeholder="https://www.dropbox.com/s/..." style="flex:1; margin-bottom:0;" />
          <button id="load-url-btn" class="secondary">Load</button>
        </div>
        <div class="small-note">Paste a Dropbox share link</div>
      </div>
    </div>

    <div id="file-info-container" class="hidden" style="margin-top: 12px; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
      <div id="file-info" style="font-weight: 700;"></div>
      <button id="auto-detect-btn" class="secondary">‚ú® AI Auto Analyze PDF</button>
    </div>

    <div id="url-error" class="hidden" style="margin-top: 10px; padding:10px; background:#fee2e2; color:#991b1b; border-radius:8px; font-size:13px;"></div>

    <div class="preview-wrap hidden" id="preview-wrap">
      <div>
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
          <button id="prev-page-btn" class="secondary">‚Üê</button>
          <input id="preview-page-input" type="number" value="1" min="1" style="width:90px; margin-bottom:0;">
          <button id="next-page-btn" class="secondary">‚Üí</button>
          <select id="preview-scale" style="width: 150px; margin-bottom: 0;">
            <option value="1">100%</option>
            <option value="1.25">125%</option>
            <option value="1.5" selected>150%</option>
            <option value="2">200%</option>
          </select>
        </div>
        <canvas id="preview-canvas"></canvas>
        <div class="small-note">Click the AI button to populate ToC + chapters automatically.</div>
      </div>
    </div>
  </div>

  <!-- Step 2 -->
  <div class="card hidden" id="step2">
    <h2><span class="step-number">2</span> Page Offset</h2>
    <p class="small-note">Configure how printed page numbers map to PDF pages. AI will fill this automatically.</p>

    <div style="display:flex; gap:20px; flex-wrap:wrap;">
      <div style="flex:1; min-width:250px;">
        <label>Content starts on PDF page:</label>
        <div style="display:flex; gap:8px; align-items:center;">
          <input type="number" id="page-offset" value="1" min="1" style="width:100px; margin-bottom:0;">
          <button id="set-offset-to-preview" class="secondary" style="padding:8px 10px;">‚Üê Use Current</button>
          <button id="reset-offset" class="secondary" style="padding:8px 10px;">Reset</button>
        </div>

        <div style="margin-top:12px;">
          <label style="display:flex; gap:8px; align-items:center; font-weight:600;">
            <input type="checkbox" id="custom-first-page-toggle" style="width:auto; margin:0;">
            Document starts on a page other than 1
          </label>
        </div>

        <div id="custom-first-page-section" style="display:none; margin-top:10px; padding:12px; background:#fefce8; border:1px solid #fef08a; border-radius:8px;">
          <label style="font-size: 0.9em;">First page number in document:</label>
          <input type="number" id="first-page-number" value="1" min="1" style="width:140px; margin-bottom:0;">
          <div class="small-note">Example: 407 for a journal issue</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Step 3 -->
  <div class="card hidden" id="step3">
    <h2><span class="step-number">3</span> Chapters</h2>

    <div style="background:#eff6ff; border:1px solid #bfdbfe; border-radius:10px; padding:16px;">
      <div style="font-weight:800; color:#1d4ed8; margin-bottom:6px;">‚ú® AI Auto Analyze</div>
      <div class="small-note">Uses your backend <code>/analyze-pdf-ai</code> to detect ToC range + chapters.</div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button id="extract-btn" class="success">‚ú® Run AI Analysis</button>
        <span id="page-range-hint" style="font-size:13px; color:#666;"></span>
      </div>

      <div id="extract-status" class="status-box hidden"></div>

      <div style="margin-top:12px; display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
        <label style="display:flex; gap:6px; align-items:center; font-weight:700;">
          ToC start:
          <input type="number" id="toc-start-page" value="1" min="1" style="width:90px; margin:0;">
        </label>
        <label style="display:flex; gap:6px; align-items:center; font-weight:700;">
          ToC end:
          <input type="number" id="toc-end-page" value="1" min="1" style="width:90px; margin:0;">
        </label>
        <button id="set-toc-current-btn" class="secondary">Set ToC to current page</button>
      </div>
    </div>

    <div class="toolbar">Drag to reorder</div>

    <div id="chapter-list"></div>

    <button id="add-chapter-btn" class="secondary" style="width:100%;">+ Add Chapter Manually</button>
  </div>

  <!-- Step 4 -->
  <div class="card hidden" id="step4">
    <h2><span class="step-number">4</span> Generate PDF</h2>

    <label style="font-size: 0.9em;">Output filename</label>
    <input type="text" id="output-filename" placeholder="processed_document.pdf">

    <button id="process-btn" class="success" style="width:100%; font-size:16px;">Download PDF with Bookmarks</button>
    <div id="status" class="status-box hidden"></div>
  </div>

  <script>
    const PDFJS_VERSION = "3.11.174";
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${PDFJS_VERSION}/pdf.worker.min.js`;

    function $(id) { return document.getElementById(id); }

    // --- State ---
    let pdfDoc = null;
    let pdfBytes = null;
    let totalPages = 0;
    let currentPreviewPage = 1;

    // Page label state (kept for compatibility with the old bookmark logic)
    let pageLabels = null;
    let pageLabelIndexByLabel = null;
    let detectedMaxRoman = 0;

    // DOM refs used by bookmark logic
    const chapterListEl = $("chapter-list");
    const pageOffsetInput = $("page-offset");

    // --- Backend helpers ---
    function getBackendBaseUrl() {
      const inp = $("backend-url");
      let base = (inp && inp.value ? inp.value : "").trim();
      return base.replace(/\/+$/, "");
    }

    function escapeHtml(str) {
      if (str == null) return "";
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function setBackendStatus(text, isError=false) {
      const el = $("backend-status");
      if (!el) return;
      el.textContent = text || "";
      el.style.color = isError ? "#b91c1c" : "#666";
    }

    async function testBackend() {
      const base = getBackendBaseUrl();
      if (!base) { setBackendStatus("Backend URL required.", true); return { ok:false, gemini_available:false }; }
      setBackendStatus("Checking‚Ä¶");
      try {
        const res = await fetch(`${base}/health`);
        if (!res.ok) { setBackendStatus(`Backend error (${res.status}).`, true); return { ok:false, gemini_available:false }; }
        const data = await res.json();
        const gem = !!data.gemini_available;
        setBackendStatus(gem ? "Backend OK. AI ready." : "Backend OK, but AI not available.", !gem);
        return { ok:true, gemini_available:gem };
      } catch {
        setBackendStatus("Cannot reach backend.", true);
        return { ok:false, gemini_available:false };
      }
    }

    function showAiStatus(text, kind="processing") {
      const box = $("extract-status");
      box.classList.remove("hidden");
      box.className = `status-box ${kind}`;
      box.innerHTML = text;
    }

    // --- PDF Load helpers ---
    async function loadPdfFromBytes(bytes, filename="document.pdf") {
      pdfBytes = bytes;
      const loadingTask = pdfjsLib.getDocument({ data: bytes });
      pdfDoc = await loadingTask.promise;
      totalPages = pdfDoc.numPages;

      $("file-info").textContent = `${filename} | ${totalPages} pages`;
      $("file-info-container").classList.remove("hidden");

      $("preview-wrap").classList.remove("hidden");
      ["step2", "step3", "step4"].forEach(id => $(id).classList.remove("hidden"));

      renderPreview(1);

      // Auto-run AI after load
      await aiAnalyzePdf();
    }

    async function loadFromUrl() {
      const urlInput = $("pdf-url");
      const errorEl = $("url-error");
      const url = (urlInput.value || "").trim();

      errorEl.classList.add("hidden");

      if (!url) {
        errorEl.textContent = "Please enter a URL";
        errorEl.classList.remove("hidden");
        return;
      }

      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
        const bytes = await res.arrayBuffer();
        await loadPdfFromBytes(bytes, "Dropbox PDF");
      } catch (err) {
        errorEl.textContent = err.message;
        errorEl.classList.remove("hidden");
      }
    }

    // --- Preview ---
    async function renderPreview(pageNum) {
      if (!pdfDoc) return;
      currentPreviewPage = Math.max(1, Math.min(totalPages, pageNum));
      $("preview-page-input").value = currentPreviewPage;

      const page = await pdfDoc.getPage(currentPreviewPage);
      const scale = Number($("preview-scale").value || 1.5);
      const viewport = page.getViewport({ scale });

      const canvas = $("preview-canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = viewport.width;
      canvas.height = viewport.height;

      await page.render({ canvasContext: ctx, viewport }).promise;
    }

    function previewPage(delta) {
      renderPreview(currentPreviewPage + delta);
    }

    function setTocRangeFromCurrentPage() {
      $("toc-start-page").value = currentPreviewPage;
      $("toc-end-page").value = currentPreviewPage;
    }

    // --- Chapter list ---
    function addChapterWithData(title, page) {
      const row = document.createElement("div");
      row.className = "chapter-row";

      const handle = document.createElement("span");
      handle.className = "drag-handle";
      handle.textContent = "‚ãÆ‚ãÆ";
      handle.draggable = true;

      const titleInput = document.createElement("input");
      titleInput.type = "text";
      titleInput.className = "chapter-title";
      titleInput.value = title || "";
      titleInput.placeholder = "Title";

      const pageInput = document.createElement("input");
      pageInput.type = "text";
      pageInput.className = "chapter-page";
      pageInput.value = page || "";
      pageInput.placeholder = "Pg (e.g., 12, iv, pdf:7)";

      const del = document.createElement("button");
      del.className = "del-btn";
      del.textContent = "√ó";
      del.onclick = () => row.remove();

      const msg = document.createElement("div");
      msg.className = "validation-msg";

      row.appendChild(handle);
      row.appendChild(titleInput);
      row.appendChild(pageInput);
      row.appendChild(del);
      row.appendChild(msg);

      // Drag reorder (no undo/redo, just reorder)
      handle.addEventListener("dragstart", (e) => {
        row.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
      });
      handle.addEventListener("dragend", () => row.classList.remove("dragging"));
      row.addEventListener("dragover", (e) => {
        e.preventDefault();
        const dragging = document.querySelector(".dragging");
        if (dragging && dragging !== row) {
          const box = row.getBoundingClientRect();
          const offset = e.clientY - box.top - box.height / 2;
          if (offset < 0) row.parentNode.insertBefore(dragging, row);
          else row.parentNode.insertBefore(dragging, row.nextSibling);
        }
      });

      pageInput.addEventListener("input", () => validateChapterRow(row));
      pageInput.addEventListener("change", () => validateChapterRow(row));

      chapterListEl.appendChild(row);
      validateChapterRow(row);
    }

    function resetChapters() {
      chapterListEl.innerHTML = "";
    }

    function addChapter() {
      addChapterWithData("", "");
      const rows = chapterListEl.querySelectorAll(".chapter-row");
      const lastRow = rows[rows.length - 1];
      if (lastRow) lastRow.querySelector(".chapter-title").focus();
    }

    function sortChapters() {
      const rows = Array.from(chapterListEl.children);
      rows.sort((a, b) => getPageFromRow(a) - getPageFromRow(b));
      chapterListEl.innerHTML = "";
      rows.forEach(r => chapterListEl.appendChild(r));
    }

    // --- Page token mapping (restored from original) ---
    function isRomanNumeralToken(token) {
      return /^[ivxlcdm]+$/i.test(token) && isNaN(token);
    }

    function normalizePageToken(token) {
      let t = (token || "").trim();
      if (!t) return "";

      t = t.replace(/\b(page|pages|pagina|paginas|seite)\b/gi, "");
      t = t.replace(/\bp\.?\s*/gi, "");
      t = t.replace(/\bpp\.?\s*/gi, "");

      t = t.replace(/^[\s.)\],:;\-‚Äì‚Äî([\[]+/, "");
      t = t.replace(/[\s.)\],:;\-‚Äì‚Äî\]\[]+$/, "");

      t = t.trim();

      if (/^\d+$/.test(t)) return t;
      if (/^[ivxlcdm]+$/i.test(t)) return t;

      const numMatch = t.match(/(\d+)/);
      if (numMatch) return numMatch[1];

      const romanMatch = t.match(/\b([ivxlcdm]+)\b/i);
      if (romanMatch) return romanMatch[1];

      return t;
    }

    function safeParseInt(x) {
      const n = parseInt(String(x).trim(), 10);
      return Number.isFinite(n) ? n : NaN;
    }

    function romanToInt(roman) {
      const s = String(roman || "").toLowerCase();
      if (!/^[ivxlcdm]+$/.test(s)) return NaN;

      const map = { i:1, v:5, x:10, l:50, c:100, d:500, m:1000 };
      let total = 0;
      let prev = 0;

      for (let i = s.length - 1; i >= 0; i--) {
        const val = map[s[i]] || 0;
        if (val < prev) total -= val;
        else { total += val; prev = val; }
      }
      return total > 0 ? total : NaN;
    }

    function pageTokenToPdfIndex(token, options = {}) {
      const { allowRawPdfPage = false } = options;
      const raw = String(token || "").trim();

      const m = raw.match(/^pdf\s*:\s*(\d+)$/i);
      if (m) {
        const pdfPage = parseInt(m[1], 10);
        if (Number.isFinite(pdfPage) && pdfPage >= 1 && pdfPage <= totalPages) {
          return { index: pdfPage - 1, isRawPdfPage: true };
        }
        return null;
      }

      const t = normalizePageToken(token).toLowerCase();
      if (!t) return null;

      const firstPageNum = safeParseInt($("first-page-number").value) || 1;
      const contentStartPdf = safeParseInt(pageOffsetInput.value) || 1;

      if (/^\d+$/.test(t)) {
        const pageNum = safeParseInt(t);
        if (!Number.isFinite(pageNum) || pageNum < 1) return null;

        const pdfIndex = (pageNum - firstPageNum) + (contentStartPdf - 1);

        if (pdfIndex >= 0 && pdfIndex < totalPages) return pdfIndex;

        const rawPdfIndex = pageNum - 1;
        if (rawPdfIndex >= 0 && rawPdfIndex < totalPages) return { index: rawPdfIndex, isRawPdfPage: true };

        return null;
      }

      if (isRomanNumeralToken(t)) {
        if (pageLabelIndexByLabel && pageLabelIndexByLabel.has(t)) {
          return pageLabelIndexByLabel.get(t);
        }

        const rv = romanToInt(t);

        if (Number.isFinite(rv) && rv > 0 && detectedMaxRoman > 0 && contentStartPdf > 1) {
          const pdfIndex = contentStartPdf - detectedMaxRoman + rv - 2;
          return (pdfIndex >= 0 && pdfIndex < totalPages) ? pdfIndex : null;
        }

        if (Number.isFinite(rv) && rv > 0 && rv <= totalPages) return rv - 1;
      }

      return null;
    }

    function getPdfIndexValue(result) {
      if (result === null) return null;
      if (typeof result === "number") return result;
      if (typeof result === "object" && result.index !== undefined) return result.index;
      return null;
    }

    function getPageFromRow(row) {
      const token = row.querySelector(".chapter-page").value.trim();
      const result = pageTokenToPdfIndex(token);
      const idx = getPdfIndexValue(result);
      return idx === null ? 999999 : idx;
    }

    function validateChapterRow(row) {
      const pageInput = row.querySelector(".chapter-page");
      const token = (pageInput.value || "").trim();
      const msgEl = row.querySelector(".validation-msg");

      if (!totalPages) {
        row.classList.remove("invalid");
        row.classList.remove("warning");
        if (msgEl) msgEl.textContent = "";
        return true;
      }

      if (!token) {
        row.classList.remove("invalid");
        row.classList.remove("warning");
        if (msgEl) msgEl.textContent = "";
        return true;
      }

      const result = pageTokenToPdfIndex(token);
      const pdfIndex = getPdfIndexValue(result);

      if (pdfIndex === null) {
        row.classList.add("invalid");
        row.classList.remove("warning");
        if (msgEl) msgEl.textContent = `Cannot map "${token}" to a PDF page.`;
        return false;
      }

      if (typeof result === "object" && result.isRawPdfPage) {
        row.classList.remove("invalid");
        row.classList.add("warning");
        if (msgEl) msgEl.textContent = `Using as PDF page ${pdfIndex + 1} directly.`;
        msgEl.style.color = "#92400e";
        return true;
      }

      row.classList.remove("invalid");
      row.classList.remove("warning");
      if (msgEl) {
        msgEl.textContent = "";
        msgEl.style.color = "";
      }
      return true;
    }

    // --- AI Analyze ---
    async function aiAnalyzePdf() {
      const base = getBackendBaseUrl();
      if (!base) { showAiStatus("Backend URL is required.", "error"); return; }

      const health = await testBackend();
      if (!health.ok) {
        showAiStatus("Cannot reach backend. Check the URL and that the service is running.", "error");
        return;
      }
      if (!health.gemini_available) {
        showAiStatus("Backend reachable but AI unavailable. Configure API key on backend.", "warning");
        return;
      }

      const form = new FormData();
      form.append("max_pages", String(Number($("ai-max-pages").value || 40)));

      const urlVal = ($("pdf-url").value || "").trim();
      if (pdfBytes) {
        const blob = new Blob([pdfBytes], { type: "application/pdf" });
        const filename = ($("pdf-file").files?.[0]?.name) || "document.pdf";
        form.append("pdf_file", blob, filename);
      } else if (urlVal) {
        form.append("pdf_url", urlVal);
      } else {
        showAiStatus("Load a PDF file or URL first.", "error");
        return;
      }

      showAiStatus("Running AI analysis‚Ä¶", "processing");
      try {
        const res = await fetch(`${base}/analyze-pdf-ai`, { method:"POST", body: form });
        if (!res.ok) {
          const msg = await res.text();
          showAiStatus(`AI analysis failed (${res.status}): ${escapeHtml(msg)}`, "error");
          return;
        }

        const data = await res.json();

        if (data.toc_start_page) $("toc-start-page").value = data.toc_start_page;
        if (data.toc_end_page) $("toc-end-page").value = data.toc_end_page;

        if (data.content_start_pdf_page) $("page-offset").value = data.content_start_pdf_page;

        const firstNum = Number(data.first_page_number || 1);
        $("custom-first-page-toggle").checked = firstNum !== 1;
        $("first-page-number").value = String(firstNum);
        $("custom-first-page-section").style.display = $("custom-first-page-toggle").checked ? "block" : "none";

        resetChapters();
        const entries = data.entries || [];
        if (!entries.length) addChapterWithData("", "");
        else entries.forEach(e => addChapterWithData(e.title || "", String(e.page || "")));

        const conf = data.confidence ? `<div><b>Confidence:</b> ${escapeHtml(data.confidence)}</div>` : "";
        const notes = data.notes ? `<div style="margin-top:6px;"><b>Notes:</b> ${escapeHtml(data.notes)}</div>` : "";
        showAiStatus(`‚úÖ AI analysis complete.${conf}${notes}`, "success");
      } catch {
        showAiStatus("AI analysis failed due to a network error.", "error");
      }
    }

    // --- PDF Generation (bookmark logic restored from original index) ---
    async function processPdf() {
      if (!pdfBytes) return alert("No PDF loaded");

      const rows = Array.from(chapterListEl.querySelectorAll(".chapter-row"));
      let lastPage = -Infinity;
      let isUnsorted = false;

      for (const row of rows) {
        const idx = getPageFromRow(row);
        if (idx === 999999) continue;
        if (idx < lastPage) {
          isUnsorted = true;
          break;
        }
        lastPage = idx;
      }

      if (isUnsorted) {
        const shouldSort = confirm("Chapters are not in page order. Sort them now before generating?\n\nClick OK to sort, or Cancel to proceed without sorting.");
        if (shouldSort) sortChapters();
      }

      const btn = $("process-btn");
      const status = $("status");
      btn.disabled = true;
      status.className = "status-box processing";
      status.classList.remove("hidden");
      status.textContent = "Generating PDF...";

      try {
        const { PDFDocument, PDFName, PDFNumber, PDFString } = PDFLib;
        const doc = await PDFDocument.load(pdfBytes);
        const context = doc.context;

        const firstPageNum = safeParseInt($("first-page-number").value) || 1;
        const contentStartPdf = safeParseInt(pageOffsetInput.value) || 1;

        const outlineItems = [];
        const skippedItems = [];

        if (contentStartPdf > 1) {
          outlineItems.push({ title: "Front Matter", pageIndex: 0 });
        }

        chapterListEl.querySelectorAll(".chapter-row").forEach(row => {
          const title = row.querySelector(".chapter-title").value.trim();
          const pageVal = row.querySelector(".chapter-page").value.trim();
          if (!title || !pageVal) return;

          const result = pageTokenToPdfIndex(pageVal);
          const pdfIndex = getPdfIndexValue(result);

          if (pdfIndex === null) {
            skippedItems.push({ title, pageVal, reason: "Cannot map page token to a PDF page" });
            return;
          }

          outlineItems.push({ title, pageIndex: pdfIndex });
        });

        if (outlineItems.length > 0) {
          const refs = [];
          for (const item of outlineItems) {
            const pageRef = doc.getPages()[item.pageIndex].ref;
            const dict = context.obj({
              Title: PDFString.of(item.title),
              Dest: context.obj([pageRef, PDFName.of("XYZ"), null, null, null]),
              Parent: null
            });
            refs.push(context.register(dict));
          }

          const outlineDict = context.obj({
            Type: PDFName.of("Outlines"),
            First: refs[0],
            Last: refs[refs.length - 1],
            Count: PDFNumber.of(refs.length)
          });

          const outlineRef = context.register(outlineDict);

          for (let i = 0; i < refs.length; i++) {
            const item = context.lookup(refs[i]);
            item.set(PDFName.of("Parent"), outlineRef);
            if (i > 0) item.set(PDFName.of("Prev"), refs[i - 1]);
            if (i < refs.length - 1) item.set(PDFName.of("Next"), refs[i + 1]);
          }

          doc.catalog.set(PDFName.of("Outlines"), outlineRef);
          doc.catalog.set(PDFName.of("PageMode"), PDFName.of("UseOutlines"));
        }

        // Page labels
        const nums = [];
        if (contentStartPdf > 1) {
          nums.push(PDFNumber.of(0));
          nums.push(context.obj({ S: PDFName.of("r"), St: PDFNumber.of(1) }));
          nums.push(PDFNumber.of(contentStartPdf - 1));
          nums.push(context.obj({ S: PDFName.of("D"), St: PDFNumber.of(firstPageNum) }));
        } else {
          nums.push(PDFNumber.of(0));
          nums.push(context.obj({ S: PDFName.of("D"), St: PDFNumber.of(firstPageNum) }));
        }
        const labelsDict = context.obj({ Nums: nums });
        doc.catalog.set(PDFName.of("PageLabels"), context.register(labelsDict));

        const data = await doc.save();
        const blob = new Blob([data], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);

        let outputFilename = $("output-filename").value.trim();
        if (!outputFilename) outputFilename = "processed_document.pdf";
        else if (!outputFilename.toLowerCase().endsWith(".pdf")) outputFilename += ".pdf";

        const a = document.createElement("a");
        a.href = url;
        a.download = outputFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        const chapterCount = outlineItems.length - (contentStartPdf > 1 ? 1 : 0);
        if (skippedItems.length > 0) {
          status.className = "status-box warning";
          status.textContent = "";
          status.appendChild(document.createTextNode(
            `PDF generated with ${outlineItems.length} bookmarks (${chapterCount} chapters${contentStartPdf > 1 ? " + Front Matter" : ""}). `
          ));

          const skippedDiv = document.createElement("div");
          skippedDiv.style.marginTop = "10px";

          const strongEl = document.createElement("strong");
          strongEl.textContent = `${skippedItems.length} chapter(s) skipped:`;
          skippedDiv.appendChild(strongEl);

          const ul = document.createElement("ul");
          ul.style.margin = "8px 0 0 18px";
          for (const item of skippedItems) {
            const li = document.createElement("li");
            li.textContent = `"${item.title}" (page ${item.pageVal}) - ${item.reason}`;
            ul.appendChild(li);
          }
          skippedDiv.appendChild(ul);
          status.appendChild(skippedDiv);
        } else {
          status.className = "status-box success";
          status.textContent = `PDF generated with ${outlineItems.length} bookmarks (${chapterCount} chapters${contentStartPdf > 1 ? " + Front Matter" : ""}).`;
        }
      } catch (err) {
        console.error(err);
        const status = $("status");
        status.className = "status-box error";
        status.textContent = "Error: " + err.message;
      } finally {
        $("process-btn").disabled = false;
      }
    }

    // --- Events ---
    document.addEventListener("DOMContentLoaded", () => {
      $("backend-test-btn").addEventListener("click", testBackend);

      $("pdf-file").addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        const bytes = await file.arrayBuffer();
        await loadPdfFromBytes(bytes, file.name);
      });

      $("load-url-btn").addEventListener("click", loadFromUrl);
      $("auto-detect-btn").addEventListener("click", aiAnalyzePdf);
      $("extract-btn").addEventListener("click", aiAnalyzePdf);

      $("prev-page-btn").addEventListener("click", () => previewPage(-1));
      $("next-page-btn").addEventListener("click", () => previewPage(1));
      $("preview-scale").addEventListener("change", () => renderPreview(currentPreviewPage));
      $("preview-page-input").addEventListener("change", () => renderPreview(Number($("preview-page-input").value || 1)));

      $("set-toc-current-btn").addEventListener("click", setTocRangeFromCurrentPage);

      $("custom-first-page-toggle").addEventListener("change", () => {
        const checked = $("custom-first-page-toggle").checked;
        $("custom-first-page-section").style.display = checked ? "block" : "none";
        if (!checked) {
          $("first-page-number").value = "1";
        }
        Array.from(chapterListEl.querySelectorAll(".chapter-row")).forEach(r => validateChapterRow(r));
      });

      $("set-offset-to-preview").addEventListener("click", () => {
        $("page-offset").value = currentPreviewPage;
        Array.from(chapterListEl.querySelectorAll(".chapter-row")).forEach(r => validateChapterRow(r));
      });

      $("reset-offset").addEventListener("click", () => {
        $("page-offset").value = 1;
        Array.from(chapterListEl.querySelectorAll(".chapter-row")).forEach(r => validateChapterRow(r));
      });

      $("add-chapter-btn").addEventListener("click", addChapter);
      $("process-btn").addEventListener("click", processPdf);

      testBackend();
    });
  </script>
</body>
</html>
